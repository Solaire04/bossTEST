#!/bin/bash
# the next line restarts using wish\
LD_LIBRARY_PATH="/opt/ASI_linux_mac_SDK_V1.38/lib/x64:$LD_LIBRARY_PATH" exec wish "$0" "$@"

### if the ASI libraries are installed in the search path, this is all that is needed
###exec wish "$0" "$@"

### -----------------------------------------------------------------------------
### BOSS - Brock Optical Spectroscopy Software
###   
### Requires: tcl/tk, blt, tclib, libtk-img, tklib, bwidget, critcl and C compiler and tools; try:
###   sudo apt-get build-essential tcl-dev tk-dev blt-dev critcl bwidget tklib libtk-img
### For camera support, needs the shared object library from ZWO: look in https://www.zwoastro.com/software/
### Assumed installed in /opt/ASI_linux_mac_SDK_V1.38 or something similar
### ZWO installation provides several udev rules, e.g. /etc/udev/rules.d/99-zwo.rules as distributed
###
### Written by edward.sternin@brocku.ca
### 2025.06: initial release, tk8.6 Ubuntu 24.04LTS, for ASI294MM and ASI2600MM (mono) cameras
###

### at runtime, can set the DEBUG flag, if passed as the first parameter
set DEBUG 0
switch -- $argc {
  0 { }
  1 { if {[lindex $argv 0]=="DEBUG"} { set DEBUG 1 } }
  default { puts stderr "$APPNAME invoked with too many arguments ($argc), abort."; exit}
  }

set APPNAME     [lindex [file split [info script]] end]
set PLATFORM    [lindex [array get tcl_platform os] 1]
set VERSION     2025.06.26

if {$DEBUG} {puts stderr "DEBUG: $APPNAME@$PLATFORM invoked with DEBUG"}

set PWD         [pwd]
set RCNAME      [file join [cd; pwd] .${APPNAME}rc]
set MIN_W       1080
set MIN_H       720
set TABS        {Settings LiveView Spectrum GPIB}

set zoomFactors { 16 8 4 2 1 }
set imgZoomDefault 4

interp alias {} chr {} format %c

set DEFAULTS    {
  targetTemp    {v 5		h "sensor cooling target, down to 35\u00B0C below ambient" }
  expTime	{v 100 		h "exposure time" }
  expUnit	{v "ms"		h "time units" }
  imgZoom	{v 4		h "camera image zoom factor" }
  macroFile	{v ""		h "file(.bcm) with BOSS Command Macro script" }
  ROI		{v "0 1200 2821 1250" h "Region Of Interest, in pixels" }
  gpibCommands	{v "id *IDN? reset *RST triac O2000] volt \{MEAS:VOLT:DC? DEF,DEF\}" h "Known GPIB commands" }
  }

#set GPIB [dict create \
#  id	"*IDN?" \
#  reset	"*RST" \
#  triac	"O2000[chr 0x00]" \
#  volt	"MEAS:VOLT:DC? DEF,DEF" \
#  ]

### ensure all needed libraries are available ---------------------------------------

if { [catch {package require Tk}] } {
  puts stderr "Tk package is missing, maybe `sudo apt-get install tk`\n"; exit 1
  }\
else {
  catch { tk_getOpenFile foo bar }
  if { [namespace exists ::tk::dialog] } {
    # some tcl/tk implementations do not implement ::tk::dialog
    # do a dummy file load, to import the ::dialog:: space, change these tkfbox settings
    # from the system-wide defaults, typically in /usr/share/tk8.5/tkfbox.tcl
    if {$DEBUG} { puts stderr "DEBUG: changing the defaults settings for hidden files" }
    set ::tk::dialog::file::showHiddenBtn 1
    set ::tk::dialog::file::showHiddenVar 0
    }
  } 
if { [catch {package require Tcl; package require tcl::chan::string; package require base64 }] } {
  puts stderr "tcllib is missing, maybe `sudo apt-get install tcllib`\n"; exit 1
  }  
if { [catch {package require tooltip }] } {
  puts stderr "tklib is missing, maybe `sudo apt-get install tklib`\n"; exit 1
  }  
if { [catch {package require Img; package require img::raw}] } {
  puts stderr "Img package is missing, maybe `sudo apt-get install img`\n"; exit 1
  }
if { [catch {package require BWidget}] } {
  puts stderr "BWidget package is missing, maybe `sudo apt-get install bwidget`\n"; exit 1
  }
if { [catch {package require critcl}] } {
  puts stderr "critcl package is missing, maybe `sudo apt-get install critcl`\n"; exit 1
  }
if { [catch {set BLTversion [package require BLT]}] } {
  puts stderr "BLT package is missing, maybe `sudo apt-get install blt`\n"; exit 1
  }
namespace import ::blt::*
proc InitCrosshairs {g} {Blt_Crosshairs $g; Blt_ZoomStack $g}
if { [catch {package require GpibLib}] } {
  puts stderr "GpibLib package is missing, download from https://github.com/slazav/tcl-gpib"
  exit 1
  }

### include the base64-encoded images for buttons ----------------------

image create photo button_open -data {
R0lGODdhGAAYAPYAAP///wcHBwgICBMTExQUFBYWFhwcHB8fHycnJy8vL0BAQCsrK0pKSjIy
Ml5eXk5OTjY2Njs7O1hYWGFhYT09PVJSUj8/P1VVVUZGRmhoaFFRUVNTU2tra19fX3FxcWBg
YGNjY3JycoKCgpGRkZKSkpaWlpeXl5ubm5ycnHt7e39/f6CgoKGhoY6OjqOjo4WFhYmJiYeH
h6Wlpaampqenp56enoqKiqqqqpCQkK6urpOTk6ioqLKysrOzs52dnZ+fn7a2tq2traKiori4
uLm5ubq6uqSkpKmpqaurq6ysrMDAwK+vr7GxscPDw8TExLu7u8rKysvLy8zMzM3Nzb6+vs7O
zsHBwcLCwsXFxcnJyc/Pz9TU1NjY2Nra2t/f3+Dg4OPj4+Xl5ejo6O3t7e7u7u/v7/Dw8PHx
8fLy8vPz8/T09Pr6+vv7+/z8/AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAACwAAAAAGAAYAAAH/oAAgoOEhYaHgxAuP4yNjj8aiIJIkoJo
LoQDGxecHTQAbG2io21ra2NHhBZUrFQ0VgBQTDw9PLQ8TFdjn4MUPCoqNjRsZGRoampoZ2dl
ZWldmIlPOjo0XmZaKDLbMiwsNFhmTkuEEUsnL0JiVVBZ7lFZUVJZX1k+H4QNJkY4YFtBK1b8
qEHwh4skXu4VQqBixY4iHhxInChxwgSKDi4IMsBhBhcYUKLIkzKlypSSVVKqnCCoAAgXYTI4
oUGzpk2bRSQIEvDghxQOM28KpbmDwaALSZSUaDJUKI8aBQZhuBEiyJAZM7htw6qViAgBvWK0
UJLDG4uAZ816ywHkAaEFPilk9DhBF0XdE3ZR2L0h4kCmDEpolBhMeLAJwlgrFAoggYRjxyMi
R4Y8woWJBIYIYNxMUUGlz6BDix5NWlIgADs=
   }
image create photo button_attach -data {
   R0lGODdhEAAQAPMAAAAAANzc3MPDw4CAgFhYWKCgoMDAAP//////AEBAAAAAAAAAAAAAAAAA
   AAAAAAAAACwAAAAAEAAQAAAEPhDISau9OGuAzJZdkh0CZ4jYEQQlalKDsLJTSBHxXNo3Lq+t
   C0GQYxVGhVwylcQ1L4cjADcgQKUSgvWC/UQAADs=
   }
image create photo button_detach -data {
   R0lGODdhEAAQAPIAAAAAANzc3P///6CgoMPDw4CAgFhYWDAwMCwAAAAAEAAQAAADSQi6zDIt
   qieFXTSKwAXI0sAFwlERitiZDoceKskUxIgC6q0YtA3AhALDwKu5FAVDwxA0EiBKzaA3lXym
   PGwFAuAlt8NohGttJAAAOw==
   }

### tcl-to-C access through critcl -------------------------------------

if {$DEBUG} { puts stderr "DEBUG: [package ifneeded critcl [package present critcl]]" }

### hardware access API through the manufacturer's C library; this may need to be added to LD_LIBRARY_PATH at run-time
critcl::cheaders -I/opt/ASI_linux_mac_SDK_V1.38/include
critcl::clibraries -L/opt/ASI_linux_mac_SDK_V1.38/lib/x64
critcl::clibraries -lASICamera2

critcl::ccode {
  #include <string.h>
  #include <stdbool.h>
  #include <tcl.h>
  #include "ASICamera2.h"
  static char *YN[2] = { "no", "yes" };
  }

critcl::cproc ASIGetNumOfConnectedCameras {} int { return ASIGetNumOfConnectedCameras(); }

critcl::cproc ASIConnectToCamera {int CameraID} int {
  bool res = ASIOpenCamera(CameraID);
  return res ? TCL_ERROR : TCL_OK ;
  }

critcl::cproc ASIInitCamera {int CameraID} int {
  bool res = ASIInitCamera(CameraID);
  return res ? TCL_ERROR : TCL_OK ;
  }

critcl::cproc ASICloseCamera {int CameraID} int { 
  bool res = ASIInitCamera(CameraID);
  res += ASICloseCamera(CameraID);
  return res ? TCL_ERROR : TCL_OK ;
  }

critcl::cproc ASIGetCameraMode {int i} int {
  ASI_CAMERA_MODE cameraMode;
  ASIGetCameraMode(i,&cameraMode);
  return cameraMode;
  }

critcl::cproc ASIGetCameraInfo {int i} object0 {
  ASI_CAMERA_INFO cameraInfo;
  ASIGetCameraProperty(&cameraInfo,i);
  char str[256], vformats[64] = "", bins[64] = "", dum[64];
  int j;
  for (j=0; j<8; j++) {
    if (cameraInfo.SupportedVideoFormat[j] == ASI_IMG_END ) { break; };
    strncpy(dum, vformats, 64);
    sprintf(vformats,"%s %d",dum,cameraInfo.SupportedVideoFormat[j]);
    }
  for (j=0; j<16; j++) {
    if (cameraInfo.SupportedBins[j] == 0 ) { break; };
    strncpy(dum, bins, 64);
    sprintf(bins,"%s %d",dum,cameraInfo.SupportedBins[j]);
    }
  sprintf(str,"id %d name {%s} width %ld height %ld bitdepth %ld pixelsize %.3fnm colour %s cooler %s shutter %s usb3 %s vformats { %s } bins { %s }", 
    cameraInfo.CameraID, cameraInfo.Name, 
    cameraInfo.MaxWidth, cameraInfo.MaxHeight, 
    cameraInfo.PixelSize, cameraInfo.BitDepth,
    YN[cameraInfo.IsColorCam], YN[cameraInfo.IsCoolerCam],
    YN[cameraInfo.MechanicalShutter], YN[cameraInfo.IsUSB3Camera], vformats, bins
    );
  Tcl_Obj* ret = Tcl_NewStringObj (str, -1);
  return ret;
  }

critcl::cproc ASIGetNumOfControls {int CameraID} int {
  int nControls = 0;
  ASIGetNumOfControls(CameraID,&nControls);
  return nControls;
  }

critcl::cproc ASIGetControlValue {int CameraID int j} object0 {
  ASI_CONTROL_CAPS cc;
  ASIGetControlCaps(CameraID, j, &cc);
  long lVal;
  ASI_BOOL bAuto;
  ASIGetControlValue(CameraID, cc.ControlType, &lVal, &bAuto);
  char s[128];
  sprintf(s,"%s {value %ld min %ld max %ld auto %s index %d} ", cc.Name, lVal, cc.MinValue, cc.MaxValue, YN[bAuto], j);
  Tcl_Obj* ret = Tcl_NewStringObj (s, -1);
  return ret;
  }

critcl::cproc ASISetControlValue {int CameraID int j int val int isAuto} int {
  ASI_CONTROL_CAPS cc;
  ASIGetControlCaps(CameraID, j, &cc);
  long lVal = (long)val;
  ASI_BOOL bAuto = isAuto ? ASI_TRUE : ASI_FALSE;
  return ASISetControlValue(CameraID, cc.ControlType, lVal, bAuto);
  }

critcl::cproc ASISetROIFormat {int CameraID int width int height int bin int type } int {
  return ASISetROIFormat(CameraID, width, height, bin, type);
  }

critcl::cproc ASIStartExposure {int CameraID} int {
  return ASIStartExposure(CameraID, ASI_FALSE);
  }

critcl::cproc ASIGetExpStatus {int id} int {
  ASI_EXPOSURE_STATUS status;
  ASIGetExpStatus(id,&status); 
  return status;
  }

critcl::cproc ASIStopExposure {int CameraID} int {
  return ASIStopExposure(CameraID);
  }

critcl::cproc ASIGetDataAfterExp {int cameraId int imgSize} object0 {
  unsigned char* imgBuf = ckalloc(imgSize); /* in C:  unsigned char* imgBuf = new unsigned char[imgSize]; */
  ASIGetDataAfterExp(cameraId, imgBuf, imgSize);
  Tcl_Obj* ret = Tcl_NewByteArrayObj (imgBuf, imgSize);
  ckfree(imgBuf);
  return ret;
  }

critcl::load

if {$DEBUG} { puts stderr "DEBUG: all critcl subroutines have been declared" }

### tcl service routines and C wrappers ----------------------------------------

proc setStatus { state message } {
   global .status.led .status.text
   if     { $state == "ok" }      { .status.led configure -background lightgreen }\
   elseif { $state == "error" }   { .status.led configure -background red }\
   elseif { $state == "warning" } { .status.led configure -background yellow }\
   else                           { .status.led configure -background white }
   .status.text configure -text "$message"
   }

proc DefaultGeometry {} {
  global DEBUG MIN_W MIN_H
  set wmW [expr max([winfo screenwidth . ]/2,$MIN_W)]
  set wmH [expr max([winfo screenheight . ]/2,$MIN_H)]
  ### dividing by 8 (not 4) places wm . closer to the top left than to bottom right
  set wmX [expr $wmW / 8]
  set wmY [expr $wmH / 8]
  set wmG "${wmW}x${wmH}+${wmX}+${wmY}"
  if ($DEBUG) { puts stderr "DEBUG: $wmW x $wmH screen detected, shifting by +$wmX,+$wmY" }
  return $wmG
  } 
   
proc AddZoomStack { g } {
  global zoomInfo
  set cmd {}
  foreach margin { xaxis yaxis x2axis y2axis } {
    foreach axis [$g $margin use] {
      set min [$g axis cget $axis -min]; set max [$g axis cget $axis -max]
      set c [list $g axis configure $axis -min $min -max $max]
      append cmd "$c\n"
      }
    }
  set zoomInfo($g,stack) [linsert $zoomInfo($g,stack) 0 $cmd]
  }

proc newVector { name len } {
  # BLT 2.x allows to re-create existing vectors, but this is cleaner
  if { [info exists ${name}] } { vector destroy ${name} }
  if {$len != "" && $len > 0} {
    vector create ${name}($len)
  } else {
    vector create ${name}
    }
  }

proc SaveSettings { interactive fname } {
  global DEBUG settings WorkDir 
  if ($interactive) {
    set filename [tk_getSaveFile -filetypes { {{Config files} {.cfg .CFG}} {{All Files} *} } \
      -initialfile [join "[file rootname [file tail $fname]] .cfg" ""] -initialdir $WorkDir]
    if { $filename == "" } { setStatus "warning" "Save operation cancelled by user"; return }
    }\
  else {
    set filename ${fname}
    }
  if { [catch {set file [open $filename "w"]}] } {
    setStatus "error" "Unable to write to \"$filename\", check write permissions"
    return
    }\
  else {
    setStatus "ok" "Saving current settings to $filename"
    foreach paramName [dict keys $settings] {
      global $paramName ${paramName}_h
      set pV [set $paramName]
      set pH [set ${paramName}_h]
      dict set settings $paramName "v \"$pV\" h \"$pH\""
      set paramValue [dict get $settings $paramName]
      if ($DEBUG) { puts stderr "DEBUG: saving $paramName = {$paramValue}"}
      set pV [dict get $paramValue v]
      set pH [dict get $paramValue h]
      puts $file "$paramName\t{v \"$pV\" h \"$pH\"}" 
      }
    close $file
    }
  if {"$macroFile"!=""} { saveFile "$macroFile.bcm" }
  }

proc LoadSettings { interactive fname } {
  global DEBUG settings WorkDir imgZoom targetTemp expTime expUnit
  if ($interactive) {
    set filename [tk_getOpenFile -filetypes { {{Config files} {.cfg .CFG}} {{All Files} *} } -initialfile $fname -initialdir $WorkDir]
    if { $filename == "" } { setStatus "warning" "Load operation cancelled by user"; return }
    }\
  else {
    set filename $fname
    }
  if { [catch {set file [open $filename "r"]}] } {
    if ($DEBUG) { puts stderr "DEBUG: File missing/unable to read \"$filename\", check read permissions" }
    return
    }\
  else {
    if ($DEBUG) { puts stderr "DEBUG: Loading settings from $filename" }
    set settings [read $file]
    close $file
    UpdateSettings
    }
  }

proc UpdateSettings {} {
  global DEBUG settings
  foreach paramName [dict keys $settings] {
    global $paramName ${paramName}_h
    set paramValue [dict get $settings $paramName]
    if {$DEBUG} { puts stderr "DEBUG: $paramName = $paramValue"}
    set $paramName [dict get $paramValue v]
    set ${paramName}_h [dict get $paramValue h]
    }
  }

proc SaveROI {x1 y1 x2 y2 fname} {
  global DEBUG imgImg imgType RAW_IMG_TYPE WorkDir
  if { $fname == "" } { 
    set filename [tk_getSaveFile -filetypes { {{raw} {.raw .RAW}} {{png} {.png .PNG}} {{All Files} *} } \
      -initialdir $WorkDir -initialfile img-[clock format [clock seconds] -format %Y%m%d%H%M%S]]
    if { $filename == "" } { setStatus "warning" "Save operation cancelled by user"; return }
    }\
  else { set filename $fname }
  set ftype [string trimleft [string tolower [file extension $filename]] "."]

  set imgH [image height $imgImg]
  set imgW [image width $imgImg]
  if {[expr $imgW*$imgH] == 0} { setStatus "error" "there is no image to save"; return } 
  set h_size [expr $x2 - $x1]
  set v_size [expr $y2 - $y1]
  if {[expr $h_size*$v_size] == 0} { setStatus "error" "there is no ROI to save"; return } 
  if {$DEBUG} { puts stderr "DEBUG: saving $h_size x $v_size ROI from $imgH x $imgW $RAW_IMG_TYPE($imgType) image" }
  
  switch $ftype {
    raw -
    png {
      if { [catch {set fp [open $filename "w"]}] } {
        setStatus "error" "Error opening file \"$filename\", check write permissions"; return }
      set AOI [base64::decode [$imgImg data -format $ftype -grayscale -from $x1 $y1 $x2 $y2]]
      if {$DEBUG} { puts stderr "DEBUG: AOI is $h_size x $v_size, [string length $AOI] bytes" }
      fconfigure $fp -translation binary -encoding binary
      puts -nonewline $fp $AOI
      close $fp
      }
    default {
      if {$DEBUG} { puts stderr "DEBUG: saving file type \"$ftype\" is not (yet) implemented"; return }
      }
    }
  setStatus "ok" "Saved ROI as $filename"
  }
    
proc saveFile { fname } {
  global DEBUG ::x ::y WorkDir cameraInfo expTime expUnit imgImg ROI
  set filename [string tolower [file rootname $fname]]
  set ftype [string trimleft [string tolower [file extension $fname]] "."]
  set file_types {}
  lappend file_types "\{ $ftype \} \{.$ftype [string toupper .$ftype] \}"
  lappend file_types { {All Files} * }
  if {$DEBUG} { puts stderr "DEBUG: filename is \"$filename\" ftype \"$ftype\"\nDEBUG: $file_types" } 
  if { "$filename" == "" } { 
    set filename [tk_getSaveFile -filetypes $file_types \
      -initialdir $WorkDir -initialfile img-[clock format [clock seconds] -format %Y%m%d%H%M%S]]
    if { "$filename" == "" } { setStatus "warning" "Save operation cancelled by user"; return }
    }\
  else {
    set filename ${fname}
    }
  # could check for existence and query to override here, but use in macros demands we plow ahead
  if { [catch {set fp [open $filename "w"]}] } {
    setStatus "error" "Error opening file \"$filename\", check write permissions"; return
    }
  set ftype [string trimleft [string tolower [file extension $filename]] "."]
  switch $ftype {
    raw {
      set AOI [base64::decode [$imgImg data -format raw -grayscale]]
      #set AOI [$imgImg data -format raw -grayscale] 
      fconfigure $fp -translation binary -encoding binary
      puts -nonewline $fp $AOI
      close $fp
      unset AOI
      setStatus "ok" "Saved current image to $filename"
      }
    png {
      close $fp
      setStatus "warning" "Compressing current image to $filename (slow)"; update
      if { [catch {$imgImg write $filename -format png -grayscale}] } {
         setStatus "error" "Error writing to \"$filename\", check write permissions"; return }\
      else { setStatus "ok" "Saved current image to $filename" }
      }
    dat -
    txt {
      if { [catch {set cI $cameraInfo(name)}] } { set cI "unknown" }
      puts $fp "# camera: $cI exposure: ${expTime}${expUnit}, image: [image width $imgImg]x[image height $imgImg], ROI: $ROI"
      for {set j 0} {$j < [::x length]} {incr j} { puts $fp "$::x($j)\t$::y($j)" }
      close $fp
      setStatus "ok" "Saved current spectrum to $filename"
      }
    bcm {
      puts -nonewline $fp [.ts.settings.macro.script get 0.0 end]
      close $fp
      setStatus "ok" "Saved command macro to $filename"
      }
    default {
      close $fp
      setStatus "warning" "File type \"$ftype\" is not yet supported"; after 1000
      }
    }
  }

proc LoadFile { type } {
  global DEBUG imgImg imgData FILE_TYPE RAW_IMG_TYPE WorkDir ROI
  set filename [tk_getOpenFile -filetypes [list $FILE_TYPE($type) {{All Files} *}] -initialdir $WorkDir ]
  if { $filename == "" } { setStatus "warning" "Load operation cancelled by user"; return }
  set ftype [string trimleft [string tolower [file extension $filename]] "."]
  switch $ftype {
    raw -
    png {
      image delete $imgImg
      set imgImg [image create photo -palette 65536]
      if { [catch [$imgImg read $filename -format $ftype]] } {
        setStatus "error" "Error opening $ftype image file \"$filename\", check permissions & format"; return }
      adjustROI
      }
    default {
      setStatus "warning" "File type \"$ftype\" is not yet supported"
      return
      }
    }
  if {$DEBUG} { puts stderr "DEBUG: loaded [image width $imgImg]x[image height $imgImg] $ftype image" }
  lset ROI 0 0;  lset ROI 2 [image width $imgImg]
  set v_shift [lindex $ROI 1]
  set v_size [expr [lindex $ROI 3] - $v_shift]
  lset ROI 3 [expr min([image height $imgImg],$v_shift + $v_size)]
  lset ROI 1 [expr [lindex $ROI 3] - $v_size]
  adjustROI
  displayImg
  }

### tcl wrappers for the ASI C library

proc findAllCameras {} {
  global listOfCameras
  if { [catch {set nCameras [ASIGetNumOfConnectedCameras]}] } { 
     setStatus "error" " No cameras found, is the power on?"
     set listOfCameras {}
     after 1000
     return
     }
  for {set i 0} {$i<$nCameras} {incr i} {
    if { [catch {ASIConnectToCamera $i}] } {
      setStatus "error" "Error accessing camera $i, are udev rules installed?"
      } \
    else {
      array set cameraInfo [ASIGetCameraInfo $i]
      lappend listOfCameras "$cameraInfo(name)"
      if { [catch {ASICloseCamera $i}] } {
        setStatus "error" " Error closing a connection to camera $i, should never happen..."
        after 1000
        exit 1
        }
      }
    }
  }

proc getControlCaps { id } {
  set nControls [ASIGetNumOfControls $id]
  set allControls ""
  for {set i 0} {$i<$nControls} {incr i} { 
    set allControls [concat $allControls [ASIGetControlValue $id $i]]
    }
  return $allControls
  }

proc getControlIndex {name} {
  global cameraControls
  if {[info exists cameraControls($name)]} {
    return [dict get $cameraControls($name) index]
    } \
  else {
    setStatus "error" " Error, control \"$name\" is not known"
    exit 1
    }
  }

proc getValue {id j} {
  array set A [lindex [ASIGetControlValue $id $j] 1]
  return $A(value)
  }
  
proc setValue {id j val} {
  if { [catch {ASISetControlValue $id $j $val 0}] } {
    setStatus "error" " Error setting control $j to value $val on camera $id"
    return TCL_ERROR
    } 
  set val_now [getValue $id $j]
  if { $val_now != $val } {
    setStatus "error" " Error setting control $j to value $val on camera $id, value now is $val_now"
    return TCL_ERROR
    } 
  return TCL_OK
  }

proc connectCamera {} {
  global DEBUG listOfCameras cameraId cameraInfo cameraControls
  set cameraNow [lindex $listOfCameras $cameraId]
  # open the selected camera
  if { [catch {ASIConnectToCamera $cameraId}] } {
    setStatus "error" " Error accessing camera $cameraId, are udev rules installed?"
    set cameraId -1
    return TCL_ERROR
    } 
  # make sure the properties and controls correspond to the chosen camera
  array set cameraInfo [ASIGetCameraInfo $cameraId]
  array set cameraControls [getControlCaps $cameraId]
  if {$DEBUG} { parray cameraInfo; parray cameraControls }
  return TCL_OK
  }

array set FILE_TYPE { raw {{raw} {.raw}} txt {{spectrum} {.txt}} conf {{config} {.cfg}} }

array set ASI_IMG_TYPE { 0 RAW8 1 RGB24 2 RAW16 3 Y8 }
array set RAW_IMG_TYPE { 0 {byte} 1 {byte} 2 {short} 3 {byte} }

array set ASI_ERROR_CODE {
   0 ASI_SUCCESS
   1 ASI_ERROR_INVALID_INDEX
   2 ASI_ERROR_INVALID_ID
   3 ASI_ERROR_INVALID_CONTROL_TYPE
   4 ASI_ERROR_CAMERA_CLOSED
   5 ASI_ERROR_CAMERA_REMOVED
   6 ASI_ERROR_INVALID_PATH
   7 ASI_ERROR_INVALID_FILEFORMATASI_CAMERA_MODE
   8 ASI_ERROR_INVALID_SIZE
   9 ASI_ERROR_INVALID_IMGTYPE
  10 ASI_ERROR_OUTOF_BOUNDARY
  11 ASI_ERROR_TIMEOUT
  12 ASI_ERROR_INVALID_SEQUENCE
  13 ASI_ERROR_BUFFER_TOO_SMALLASI_CAMERA_MODE
  14 ASI_ERROR_VIDEO_MODE_ACTIVE
  15 ASI_ERROR_EXPOSURE_IN_PROGRESS
  16 ASI_ERROR_GENERAL_ERROR
  }

array set ASI_EXPOSURE_STATUS {
   0 IDLE
   1 WORKING
   2 SUCCESS
   3 FAILED
   }

array set ASI_CAMERA_MODE {
   0 ASI_MODE_NORMAL
   1 ASI_MODE_TRIG_SOFT_EDGE
   2 ASI_MODE_TRIG_RISE_EDGE
   3 ASI_MODE_TRIG_FALL_EDGE
   4 ASI_MODE_TRIG_SOFT_LEVEL
   5 ASI_MODE_TRIG_HIGH_LEVEL
   6 ASI_MODE_TRIG_LOW_LEVEL
   } 

proc findAllCameras {} {
  global listOfCameras
  if { [catch {set nCameras [ASIGetNumOfConnectedCameras]}] } { 
     setStatus "error" " No cameras found, is the power on?"
     set listOfCameras {}
     after 1000
     return
     }
  for {set i 0} {$i<$nCameras} {incr i} {
    if { [catch {ASIConnectToCamera $i}] } {
      setStatus "error" "Error accessing camera $i, are udev rules installed?"
      } \
    else {
      array set cameraInfo [ASIGetCameraInfo $i]
      lappend listOfCameras "$cameraInfo(name)"
      if { [catch {ASICloseCamera $i}] } {
        setStatus "error" " Error closing a connection to camera $i, should never happen..."
        after 1000
        exit 1
        }
      }
    }
  }

proc getControlCaps { id } {
  #global DEBUG
  set nControls [ASIGetNumOfControls $id]
  set allControls ""
  for {set i 0} {$i<$nControls} {incr i} { 
    set allControls [concat $allControls [ASIGetControlValue $id $i]]
    #if {$DEBUG} {puts stderr "DEBUG: control $i: [ASIGetControlValue $id $i]" }
    }
  return $allControls
  }

proc getControlIndex {name} {
  global cameraControls
  if {[info exists cameraControls($name)]} {
    return [dict get $cameraControls($name) index]
    } \
  else {
    setStatus "error" " Error, control \"$name\" is not known"
    exit 1
    }
  }

proc getValue {id j} {
  array set A [lindex [ASIGetControlValue $id $j] 1]
  return $A(value)
  }
  
proc setValue {id j val} {
  if { [catch {ASISetControlValue $id $j $val 0}] } {
    setStatus "error" " Error setting control $j to value $val on camera $id"
    return TCL_ERROR
    } 
  set val_now [getValue $id $j]
  if { $val_now != $val } {
    setStatus "error" " Error setting control $j to value $val on camera $id, value now is $val_now"
    return TCL_ERROR
    } 
  return TCL_OK
  }

proc connectCamera {} {
  global DEBUG listOfCameras cameraId 
  set cameraNow [lindex $listOfCameras $cameraId]
  # open the selected camera
  if { [catch {ASIConnectToCamera $cameraId}] } {
    setStatus "error" " Error accessing camera $cameraId, are udev rules installed?"
    set cameraId -1
    return TCL_ERROR
    }
  if {$DEBUG} { puts stderr "DEBUG: camera $cameraId connected" }
  return TCL_OK
  }

proc resetCamera {} {
  global DEBUG cameraId cameraInfo cameraControls
  if {$cameraId < 0} {
    setStatus "warning" "There is no camera connected"
    return
    }
  # initialize the selected camera
  if { [catch {ASIInitCamera $cameraId}] } {
    setStatus "error" " Error initializing camera $cameraId, disconnecting"
    ASICloseCamera $cameraId
    .tbar.reset configure -fg gray
    .tbar.snap configure -fg gray
    set cameraId -1
    return TCL_ERROR
    }
  # make sure the properties and controls correspond to the chosen camera
  array set cameraInfo [ASIGetCameraInfo $cameraId]
  array set cameraControls [getControlCaps $cameraId]
  if {$DEBUG} { parray cameraInfo; parray cameraControls }
  return TCL_OK
  }

proc toggleCoolerOn {} {
  global coolerOn cameraId targetTemp 
  if {$cameraId < 0} {
    setStatus "error" "Need to connect to a camera first"
    return TCL_ERROR
    }
  set backgrounds {white cyan}
  set foregrounds {cyan white}
  set labels {OFF ON}
  set coolerOn [expr {$coolerOn ? 0 : 1}]
  if {$coolerOn} { setValue $cameraId [getControlIndex TargetTemp] $targetTemp }
  setValue $cameraId [getControlIndex CoolerOn] $coolerOn
  .ts.lv.tbar.cool configure -bg [lindex $backgrounds $coolerOn] -fg [lindex $foregrounds $coolerOn]
  setStatus "ok" "Sensor cooler is [lindex $labels $coolerOn]"
  return TCL_OK
  }

proc updateExpTime {} {
  global cameraControls expTime expUnits expUnit
  set t [expr $expTime * [dict get $expUnits $expUnit]]
  set t_min [dict get $cameraControls(Exposure) min]
  set t_max [dict get $cameraControls(Exposure) max]
  if {$t<$t_min} { set t $t_min }
  if {$t>$t_max} { set t $t_max }
  set expTime [expr $t / [dict get $expUnits $expUnit]]
  setStatus "ok" "Exposure time set to $expTime$expUnit = $t \u03BCs" 
  }


proc getSnapshot {} {
  global DEBUG run cameraId cameraInfo cameraControls expTime expUnits expUnit \
         ASI_IMG_TYPE RAW_IMG_TYPE ASI_ERROR_CODE ASI_EXPOSURE_STATUS ASI_CAMERA_MODE \
         imgData imgType imgImg imgWidth imgHeight
  #set imgType 2
  # bin1 correspond to the max resolution, but for ASI294 that is interpolated, use bin2 to match sensor resolution
  if {$cameraInfo(name) == "ZWO ASI294MM Pro" } { set binType 2 } else { set binType 1 }
  set imgWidth [expr $cameraInfo(width) / $binType]
  set imgHeight [expr $cameraInfo(height) / $binType]
  if {$DEBUG} { puts stderr "DEBUG: image ${imgWidth}x${imgHeight}, type=$imgType \u2208($cameraInfo(vformats)), bin=$binType \u2208($cameraInfo(bins))" }

  set delayLoopCount 0
  ASISetROIFormat $cameraId $imgWidth $imgHeight $binType $imgType
  after 10
  setValue $cameraId [dict get $cameraControls(Gain) index] 0
  set t [expr $expTime * [dict get $expUnits $expUnit]]
  setValue $cameraId [dict get $cameraControls(Exposure) index] $t
  set status [ASIStartExposure $cameraId]
  if {"$ASI_ERROR_CODE($status)" != "ASI_SUCCESS"} { 
    setStatus "error" "StartExposure reports $ASI_ERROR_CODE($status), aborting"
    return
    }\
  else {
    .ts.lv.tbar.snap configure -bg red -fg white
    if {$DEBUG} { puts stderr "DEBUG: exposure successfully started for [getValue $cameraId [getControlIndex Exposure]] \u03BCs" }
    }
  after 10
  image delete $imgImg
  set imgImg [image create photo -palette 65536 -width $imgWidth -height $imgHeight]
  set imgSize [expr $imgWidth * $imgHeight * (1 + [expr {"$ASI_IMG_TYPE($imgType)"=="RAW16"}])] 
  set delayLoopCount 0
  set TIME_STEP 100
  set maxLoopCount [expr $t / ($TIME_STEP*1000) + 10]; # 10 extra steps = 1s, to make sure
  if {$DEBUG} { puts stderr "DEBUG: expect LoopCount to not exceed $maxLoopCount" }
  while { $delayLoopCount < $maxLoopCount } {
    incr delayLoopCount
    set status [ASIGetExpStatus $cameraId]
    if {$DEBUG} { puts stderr "DEBUG: exposure $ASI_EXPOSURE_STATUS($status) ($delayLoopCount)" }
    if {"$ASI_EXPOSURE_STATUS($status)" == "WORKING"} {
      after $TIME_STEP
      setStatus "warning" "Waiting ($delayLoopCount) for exposure to complete [format %.1f [expr $delayLoopCount * $TIME_STEP/1000.0]]s"
      update
      }\
    elseif {"$ASI_EXPOSURE_STATUS($status)" == "SUCCESS"} { 
      set imgData [ASIGetDataAfterExp $cameraId $imgSize]
      if {$DEBUG} { puts stderr "DEBUG: [expr $imgWidth * $imgHeight] pixels requested, [expr [string length $imgData]/2] pixels received" }
      setStatus "ok" "Exposure completed in [format %.1f [expr $delayLoopCount * $TIME_STEP/1000.0]] s"; update
      $imgImg put "Magic=RAW\nWidth=$imgWidth\nHeight=$imgHeight\nNumChan=1\nByteOrder=Intel\nScanOrder=TopDown\nPixelType=$RAW_IMG_TYPE($imgType)\n$imgData" -format raw
      break
      } \
    elseif {"$ASI_EXPOSURE_STATUS($status)" == "FAILED"} {
      setStatus "error" "Exposure FAILED, aborting and resetting the camera"
      update; after 1000;
      if { [catch {ASIInitCamera $cameraId}] } {
        setStatus "error" " Error initializing camera $i, should never happen..."
        .ts.lv.tbar.snap configure -bg white -fg red
        after 1000
        return
        }
      break
      }
    }
  if { $delayLoopCount >= $maxLoopCount } {
    setStatus "error" "Exposure for [format %.1f [expr $t/1e6]]s did not complete in [format %.1f [expr $delayLoopCount * $TIME_STEP/1000.0]]s"
    update
    }
  set status [ASIStopExposure $cameraId]
  if {"$ASI_ERROR_CODE($status)" != "ASI_SUCCESS"} { 
    setStatus "error" "StopExposure reports $ASI_ERROR_CODE($status), aborting"
    .ts.lv.tbar.snap configure -bg white -fg red
    return
    }
  after 10
  if {$DEBUG} {
    puts stderr "DEBUG: image acquired in $delayLoopCount tries, with a [format %.1f [expr $delayLoopCount * 0.2]]-s delay:"
    puts stderr "  AutoExpTargetBrightness = [getValue $cameraId [getControlIndex AutoExpTargetBrightness]]"
    puts stderr "  AutoExpMaxGain = [getValue $cameraId [getControlIndex AutoExpMaxGain]]"
    puts stderr "  Exposure = [getValue $cameraId [getControlIndex Exposure]]"
    puts stderr "  Gain = [getValue $cameraId [getControlIndex Gain]]"
    puts stderr "  Temperature = [expr [getValue $cameraId [getControlIndex Temperature]] / 10.0]\u00B0C"
    }
  .ts.lv.tbar.snap configure -bg white -fg red
  displayImg
  }

proc displayImg {} { 
  global imgData imgZoom imgImg DEBUG
  set im [image create photo -palette 65536]
  $im copy $imgImg -subsample $imgZoom
  .ts.lv.main.c itemconfigure mainImg -anchor nw -image $im
  set w [expr max([winfo vrootwidth .ts.lv]-100,[image width $im]/$imgZoom+2)]
  set h [expr max([winfo vrootheight .ts.lv]-200,[image height $im]/$imgZoom+2)]
  .ts.lv.main.c configure -scrollregion [.ts.lv.main.c bbox all] -width $w -height $h 
  unset im
  setStatus "ok" "Displaying a [image width $imgImg]x[image height $imgImg] image on ${w}x$h canvas, @ zoom=1:$imgZoom"
  update
  }

proc displaySpectrum {x1 y1 x2 y2} {
  global DEBUG ::x ::y imgImg imgW imgH h_size v_size
  set h_size [expr $x2 - $x1]
  set v_size [expr $y2 - $y1]
  set imgH [image height $imgImg]
  set imgW [image width $imgImg]
  if {[expr $imgW*$imgH] == 0} { setStatus "error" "there is no image to analyze"; return } 
  #set AOI ""
  set AOI [base64::decode [$imgImg data -format raw -grayscale -from $x1 $y1 $x2 $y2]]
  #set AOI [$imgImg data -format raw -grayscale -from $x1 $y1 $x2 $y2] 
  set headerLength [expr [string length $AOI] - $h_size*$v_size - 1 ]
  if {$DEBUG} {puts stderr "DEBUG: header of $headerLength bytes is:\n[string range $AOI 0 $headerLength]" }
  set AOI [string range $AOI $headerLength end-1]
  if {$DEBUG} { puts stderr "DEBUG: AOI is $imgW x $imgH, [string length $AOI] bytes" }
  set cp [::tcl::chan::string $AOI]
  newVector ::z ""
  newVector ::col ""
  ::z binread $cp -format "u2"; ::z matrix numcols $h_size
  chan close $cp
  unset AOI
  newVector ::x $h_size
  newVector ::y $h_size
  ::x seq 0 $h_size-1
  set j_max [expr $h_size/2]
  ###set tt [time {
  #the raw format is interlaced, it assumes PixelType=byte, and we use two-byte "short"
  for {set j 0} {$j < $j_max} {incr j} {
    ::col set [::z matrix get $j]
    set ::y([expr 2*$j]) $::col(sum)
    set j2 [expr $j_max+$j]
    ::col set [::z matrix get $j2]
    set ::y([expr 2*$j+1]) $::col(sum)
    }
  ###}]
  ###puts stderr "Summing up $h_size columns of length $v_size took [format %.3f [expr [lindex $tt 0] / 1000]] ms"; unset tt
  vector destroy ::col ::z

  .ts.sp.g marker configure bg -image $imgImg
  .ts.sp.g element configure spectrum -xdata ::x -ydata ::y 
  .ts.sp.g xaxis configure -min $::x(min) -max $::x(max)
  .ts.sp.g yaxis configure -min $::y(min) -max $::y(max)
  .ts.sp.g marker configure bg -coords "$::x(min) $::y(min) $::x(max) $::y(max)"
  set y_top [expr $::y(max)-($::y(max)-$::y(min))*$y1/$imgH]
  .ts.sp.g marker configure _top -coords "$::x(min) $y_top $::x(max) $y_top"
  set y_bot [expr $::y(max)-($::y(max)-$::y(min))*$y2/$imgH]
  .ts.sp.g marker configure _bot -coords "$::x(min) $y_bot $::x(max) $y_bot"
  .ts.sp.rbar.vs configure -from 0 -to [expr $imgH - $v_size -1]
  .ts.sp.rbar.vs set $y1
  }

proc powerOff {} {
  global DEBUG run cameraId
  set run false
  if {$DEBUG} { puts stderr "DEBUG: closing the camera connection" }
  after 100
  if {$cameraId < 0} {exit}
  if { [catch {ASICloseCamera $cameraId}] } {
    setStatus "error" "Error closing a connection to camera $cameraId, should never happen..."
    update; after 1000; exit 1
    }
  exit
  }

proc atXhairs { g } {
  global DEBUG ::x ::y 
  if { ![winfo exists $g] } { return }
  set wxy [split [$g crosshairs cget -position] "," ];# window x,y
  set wx [string range [lindex $wxy 0] 1 end]; set wy [lindex $wxy 1]
  set sxy [$g invtransform [expr $wx] [expr $wy]]
  set sx [lindex $sxy 0]; set sy [lindex $sxy 1];# data x,y
  .ts.sp.rbar.x configure -text "[format {%d} [expr {int($sx)}]]"
  .ts.sp.rbar.y configure -text "[format {%.3e} $sy]"
  }


if {$DEBUG} { puts stderr "DEBUG: end of subroutine declarations" }

set basefontsize 12
set fontDefault Arial
set fontWeight normal

# on high-def displays, BLT fonts look too small.  The workaround is to use negative size, 
# which means size in points and not pixels, but need to correct for [tk scaling]
# first, create a copy of the defaults font
font create tabsetFont
set fopts [font configure TkDefaultFont]
foreach o [dict keys $fopts] { font configure tabsetFont $o [dict get $fopts $o] }
# adjust its size
font configure tabsetFont -size [expr -round([dict get $fopts -size]*[tk scaling])]

set fontSize(small)  [expr {round($basefontsize * 0.80)}]
set fontSize(base)   [expr {round($basefontsize)}]
set fontSize(large)  [expr {round($basefontsize * 1.25)}];# 1.25
foreach f { TkDefaultFont TkTextFont TkMenuFont TkCaptionFont TkIconFont TkTooltipFont } {
  font configure $f -family $fontDefault -size $fontSize(base) -weight $fontWeight
  }
font configure TkHeadingFont -family $fontDefault -size $fontSize(large) -weight $fontWeight
font configure TkSmallCaptionFont -family $fontDefault -size $fontSize(small) -weight $fontWeight
font configure TkFixedFont -family Courier -size $fontSize(base) -weight $fontWeight

# default settings
set nCameras 0
set listOfCameras [list]
set cameraId -1
set cameraNow ""
set currentTemp ""
set currentTempC "T=----"
set targetTemp 15
set coolerOn 0
set coolPowerPerc 0
set expTime 10
set expUnit ms
set expUnits { \u03BCs 1 ms 1000 s 1000000 }
set macroFile ""
set imgData ""
set imgImg [image create photo -palette 65535]
set imgZoom $imgZoomDefault
set imgType 2
set imgH $MIN_H
set imgW $MIN_W
set ROI "0 [expr $imgH/2] $imgW [expr $imgH/2+50]"
set gpib_board "0"
set dev_addr "22"

### update settings from the values saved in ~/.bossrc file
if { [catch {set file [open $RCNAME "r"]}] } {
  if {$DEBUG} { puts stderr "DEBUG: unable to read $RCNAME, defaulting all settings\n" }
  set settings [linsert $DEFAULTS 0 WorkDir "v $PWD h \"current work directory\""]
  set wmG [DefaultGeometry]
  lappend settings wmG "v $wmG h \"wm geometry\""
  }\
else {
  close $file
  LoadSettings 0 $RCNAME
  }
UpdateSettings
set v_shift [expr [lindex $ROI 1]]
set v_size [expr [lindex $ROI 3] - [lindex $ROI 1]]
set h_shift [expr [lindex $ROI 0]]
set h_size [expr [lindex $ROI 2] - [lindex $ROI 0]]

cd "$WorkDir" 
if {$DEBUG} { puts stderr "DEBUG: in $WorkDir" }

### interface --------------------------------------------------------------------------------
if {$DEBUG} { puts stderr "DEBUG: configuring GUI" }

wm geometry . $wmG; wm title . "$APPNAME v.$VERSION ($PLATFORM)"
wm minsize . $MIN_W $MIN_H
wm protocol . WM_DELETE_WINDOW {
  set answer [tk_messageBox -message "Quit $APPNAME?" -type yesno]
  if {$answer=="yes"} { set wmG [winfo geometry . ]; SaveSettings 0 $RCNAME; powerOff }
  }

### main window has tabs
  
set tabNames $TABS

blt::tabset .ts -bg grey -slant right -gap 2 -tearoff yes -scrollcommand { .st set } -selectbackground white -font tabsetFont
scrollbar .st -command {.ts view} -orient horizontal
foreach name $tabNames {.ts insert end $name}
# status bar is at the bottom of the frame
frame .status
label .status.led  -text "" -width 2 -background grey
label .status.text -text ""
pack .status -side bottom -fill x
pack .status.led .status.text -side left
pack .st -side top -fill x
pack .ts -expand 1 -fill both
pack .status -side bottom -fill x

# the first tab is Settings, report/change all control parameters
#.ts tab select Settings
frame .ts.settings
label .ts.settings.label -text "Control Parameters"
table .ts.settings 0,0 .ts.settings.label -cspan 2
set i 1
foreach paramName [dict keys $settings] {
  global $paramName ${paramName}_h
  label .ts.settings.l_${paramName} -text "$paramName"
  entry .ts.settings.v_${paramName} -textvariable $paramName
  label .ts.settings.h_${paramName} -text [set [set paramName]_h]
  table .ts.settings \
    $i,0 .ts.settings.l_${paramName} -anchor e \
    $i,1 .ts.settings.v_${paramName} \
    $i,2 .ts.settings.h_${paramName} -anchor w
  incr i
  }
  
frame .ts.settings.actions
button .ts.settings.actions.saveConfig -text "Save .cfg" -bg LightGreen -command {SaveSettings 1 $File}
button .ts.settings.actions.loadConfig -text "Load .cfg" -bg LightGreen -command {LoadSettings 1 $File}
button .ts.settings.executeMacro -text "Go" -bg LightGreen -command { executeMacro }

proc executeMacro {} {
  set script [split [.ts.settings.macro.script get 0.0 end] \n]
  for {set i 0} {$i<[llength $script]} {incr i} {
    set line [lindex $script $i]
    if {"$line"!=""} {
      setStatus "ok" "Executing \{ $line \} "
      uplevel 1 $line
      }
    } 
  }

frame .ts.settings.macro -width 60 -height 10 
#text .ts.settings.script -yscrollcommand ".ts.settings.scroll set" -setgrid true -width 40 -height 10 -background white -undo 1
text .ts.settings.macro.script -background white -yscrollcommand ".ts.settings.macro.scroll set"
if {"$macroFile" != "" } {
  if { [catch {open "$macroFile.bcm" r} fp] } {
    puts stderr "WARNING: Could not read the script from $macroFile.bcm"
    }\
  else {
    set script [read $fp]
    .ts.settings.macro.script delete 0.0 end
    .ts.settings.macro.script insert end [string trim $script]
    close $fp
    }
  }
scrollbar .ts.settings.macro.scroll -command ".ts.settings.macro.script yview"
pack .ts.settings.macro.script .ts.settings.macro.scroll -side left -fill y

pack .ts.settings.actions.saveConfig .ts.settings.actions.loadConfig -side left
table .ts.settings $i,0 .ts.settings.actions -cspan 2
table .ts.settings $i,2 .ts.settings.executeMacro
incr i
table .ts.settings $i,0 .ts.settings.macro -cspan 3 
table configure .ts.settings -propagate true

.ts tab configure Settings -window .ts.settings -anchor n

set fileName ""
newVector ::x ""
newVector ::y ""
newVector ::z ""

# the second tab is a live view of the camera field, snapshot or continuous

frame .ts.lv

frame .ts.lv.tbar -relief raised -borderwidth 1
menubutton .ts.lv.tbar.file -text "File" -relief raised -menu .ts.lv.tbar.file.m 
menu .ts.lv.tbar.file.m -tearoff 0
  .ts.lv.tbar.file.m add command -label "Load img" -command { LoadFile raw }
  .ts.lv.tbar.file.m add command -label "Save img" -command { saveFile ".raw"}
  .ts.lv.tbar.file.m add separator
  .ts.lv.tbar.file.m add command -label "Save ROI" -command { 
    set x1 [lindex $ROI 0]; set y1 [lindex $ROI 1]
    set x2 [lindex $ROI 2]; set y2 [lindex $ROI 3]
    SaveROI $x1 $y1 $x2 $y2 ""
    }

label .ts.lv.tbar.lvdev -text " camera=" 
ComboBox .ts.lv.tbar.vdev -textvariable cameraNow -values $listOfCameras -modifycmd {
  set cameraId [lsearch $listOfCameras $cameraNow]
  setStatus "ok" "Camera $cameraId: $cameraNow selected"
  connectCamera; resetCamera
  }
button .ts.lv.tbar.reset -text "\u27F3" -fg grey -command { resetCamera }

proc adjustTargetTemp {} { 
  global cameraId targetTemp
  setStatus "ok" "Target is now $targetTemp\u00B0C"
  setValue $cameraId [getControlIndex TargetTemp] $targetTemp
  }
spinbox .ts.lv.tbar.target -textvariable targetTemp -width 3 -command { adjustTargetTemp }
#bind .ts.lv.tbar.target <Leave> { adjustTargetTemp }
bind .ts.lv.tbar.target <Return> { adjustTargetTemp }

label .ts.lv.tbar.ltemp  -text "  target="
label .ts.lv.tbar.temp  -textvariable currentTempC
label .ts.lv.tbar.ltarget -text "\u00B0C  pwr=---%"
ttk::progressbar .ts.lv.tbar.coolbar -orient vertical -length 33 -mode determinate -variable coolPowerPerc
ttk::style configure TProgressbar -background cyan -thickness 5
button .ts.lv.tbar.cool -text "\u2744" -fg grey -command { toggleCoolerOn }

spinbox .ts.lv.tbar.eunit -values {\u03BCs ms s} -width 3 -textvariable expUnit -state readonly -command { updateExpTime }
set expUnit ms
entry .ts.lv.tbar.etime -textvariable expTime -width 5 -validate focus -vcmd  {string is int %P}
bind .ts.lv.tbar.etime <Return> updateExpTime
#bind .ts.lv.tbar.etime <Leave> updateExpTime

spinbox .ts.lv.tbar.zoom -values $zoomFactors -width 2 -state readonly -command { displayImg }
.ts.lv.tbar.zoom  configure -textvariable imgZoom
label .ts.lv.tbar.lz -text " zoom=1:"
button .ts.lv.tbar.snap -text "\u25C9" -fg grey -command { getSnapshot; while {$repeatSnapshot} {getSnapshot} }
checkbutton .ts.lv.tbar.loop -text "\u21BB" -variable repeatSnapshot
#button .ts.lv.tbar.exit -text "\u2716" -fg red -command { after 0 { powerOff } }

frame .ts.lv.main -relief raised -borderwidth 1
canvas .ts.lv.main.c -bg white -yscrollcommand {.ts.lv.main.vs set} -xscrollcommand {.ts.lv.main.hs set}
scrollbar .ts.lv.main.vs -orient vertical   -command {.ts.lv.main.c yview}
scrollbar .ts.lv.main.hs -orient horizontal -command {.ts.lv.main.c xview}
grid .ts.lv.main.c .ts.lv.main.vs -sticky nsew
grid               .ts.lv.main.hs -sticky nsew
grid columnconfigure .ts.lv.main .ts.lv.main.c -weight 1 ; #-minsize $MIN_W
grid rowconfigure    .ts.lv.main .ts.lv.main.c -weight 1 ; #-minsize $MIN_H
.ts.lv.main.c create image 0 0 -tags mainImg
bind .ts.lv.main <Configure> { displayImg }

pack .ts.lv.tbar.file .ts.lv.tbar.lvdev .ts.lv.tbar.vdev .ts.lv.tbar.reset .ts.lv.tbar.temp .ts.lv.tbar.ltemp \
     .ts.lv.tbar.target .ts.lv.tbar.ltarget .ts.lv.tbar.coolbar .ts.lv.tbar.cool \
     .ts.lv.tbar.etime .ts.lv.tbar.eunit .ts.lv.tbar.snap .ts.lv.tbar.loop .ts.lv.tbar.lz .ts.lv.tbar.zoom -side left
#pack .ts.lv.tbar.exit -side right
pack .ts.lv.tbar -side top -fill x
#pack .ts.lv.main.c -side top
pack .ts.lv.main -side top -expand 1 -fill both

.ts tab configure LiveView -window .ts.lv -expand 1 -fill both
.ts tab select LiveView

# the third tab is for extracting a spectrum from ROI

proc adjustROI {} {
  global ROI imgImg h_shift v_shift
  set x1 [expr max([lindex $ROI 0],0)] 
  set y1 [expr min(max([lindex $ROI 1],0),[image height $imgImg]-1)] 
  set v_size [expr max(1,[lindex $ROI 3]-$y1)]
  set x2 [expr min([lindex $ROI 2],[image width $imgImg])] 
  set y2 [expr min($y1+$v_size,[image height $imgImg])] 
  setStatus "ok" "Set ROI  to \{ $x1 $y1 $x2 $y2 \}"
  set currentRoi "$x1 $y1 $x2 $y2"
  displaySpectrum $x1 $y1 $x2 $y2
  set h_shift $x1
  set v_shift $y1
  }

frame .ts.sp
frame .ts.sp.tbar
menubutton .ts.sp.tbar.file -text "File" -relief raised -menu .ts.sp.tbar.file.m 
menu .ts.sp.tbar.file.m -tearoff 0
  .ts.sp.tbar.file.m add command -label "Save spectrum" -command { saveFile ".dat" }
  #.ts.sp.tbar.file.m add separator
label .ts.sp.tbar.lroi -text "  ROI"
entry .ts.sp.tbar.roi -textvariable ROI -width 20
bind .ts.sp.tbar.roi <Return> { adjustROI }
button .ts.sp.tbar.reset -text "\u27F3" -command { adjustROI }
#entry .ts.sp.tbar.y1 -textvariable v_shift -width 5 -validate focus -vcmd  {string is int %P}
label .ts.sp.tbar.ldy -text "band of "
entry .ts.sp.tbar.dy -textvariable v_size -width 5 -validate focus -vcmd  {string is int %P}
#bind .ts.sp.tbar.y1 <Return> { lset ROI 1 $v_shift; lset ROI 3 [expr $v_shift + $v_size]; adjustROI}
bind .ts.sp.tbar.dy <Return> { lset ROI 3 [expr $v_shift + $v_size]; adjustROI }
pack .ts.sp.tbar.file .ts.sp.tbar.lroi .ts.sp.tbar.roi .ts.sp.tbar.reset -side left -fill x
pack .ts.sp.tbar.dy .ts.sp.tbar.ldy -side right
pack .ts.sp.tbar -side top -fill x

graph .ts.sp.g -width $imgW -height $imgH -bd 2 -relief groove
.ts.sp.g axis configure x -title "pixel #" -min $h_shift -max [expr $h_shift + $imgW]
.ts.sp.g element create spectrum -xdata ::x -ydata ::y -symbol "" -linewidth 1 -color magenta
.ts.sp.g marker create image -image $imgImg -under yes -name bg
.ts.sp.g marker configure bg -coords "$::x(min) $::y(min) $::x(max) $::y(max)"
.ts.sp.g marker create line -outline cyan -linewidth 1 -name _top
.ts.sp.g marker create line -outline cyan -linewidth 1 -name _bot
.ts.sp.g legend configure -position plotarea -anchor ne -raised true -background white

frame .ts.sp.rbar
scale .ts.sp.rbar.vs -variable v_shift -from 0 -to [expr [image height $imgImg] - $v_size -1] -showvalue true -orient vertical\
  -command { lset ROI 3 [expr $v_shift + $v_size]; lset ROI 1 }
label .ts.sp.rbar.x -text "----"
label .ts.sp.rbar.y -text "----"
pack .ts.sp.rbar -side right -fill y
pack .ts.sp.rbar.y .ts.sp.rbar.x -side bottom
pack .ts.sp.rbar.vs -expand 1 -fill both
bind .ts.sp.rbar.vs <ButtonRelease> { adjustROI }
pack .ts.sp.g  -expand 1  -fill both
InitCrosshairs .ts.sp.g
bind .ts.sp.g <Motion> {atXhairs .ts.sp.g}

.ts tab configure Spectrum -window .ts.sp -anchor nw

# the fourth tab is for GPIB communications with the spectrometer

set append_null 0

set GPIB [dict create]
foreach {abbr command} $gpibCommands { dict append GPIB $abbr $command }

proc sendGPIB {cmd} {
  global DEBUG gpib_dev append_null Rxdata Txdata GPIB
  if {"$cmd"==""} { set str "$Txdata" }\
  else { if {[dict exists $GPIB $cmd]} {set str [dict get $GPIB $cmd]} else {set str "$cmd"} }
  if {$DEBUG} {puts stderr "DEBUG: GPIB command $cmd --> ${str} ([string length ${str}])"}
  if {[info exists gpib_dev]} {
    set Rxdata ""; setStatus "ok" "Sending \"$str\" to GPIB device $gpib_dev"
    if {$append_null || "$str"=="O2000"} {$gpib_dev write "$str[chr 0x00]"} else {$gpib_dev write "$str"}
    # if the sent command contained "?", expect a reply
    if {[string first "?" $str] != -1} {
      if {[catch {$gpib_dev read} Rxdata]} {set Rxdata ""; setStatus "error" "Error reading from $gpib_dev"}
      }
    }\
  else { setStatus "warning" "No GPIB device connected" }
  update
  }

proc connectGPIB { } {
  global DEBUG gpib_board dev_addr gpib_dev
  if {[info exists gpib_dev]} {
    setStatus "ok" "Disconnecting from $gpib_dev"
    $gpib_dev go_to_local
    gpib_device delete $gpib_dev
    unset gpib_dev
    .ts.gpib.tbar.link configure -image button_attach
    after 100; setStatus "" "Ready"
    }\
  else {
    set gpib_dev [gpib_device "GPIB$gpib_board:$dev_addr" -board $gpib_board -address $dev_addr -trimright \n -readymask 16]
    set dev_id [$gpib_dev cmd_read *IDN?]
    if {$DEBUG} {puts stderr "DEBUG: Found $dev_id at $gpib_board:$dev_addr"}
    $gpib_dev remote_enable
    set i [$gpib_dev ready]
    setStatus "[lindex {ok warning} $i]" "$dev_id connected as $gpib_dev, [lindex {ready busy} $i]"
    .ts.gpib.tbar.link configure -image button_detach
    }
  }

frame .ts.gpib
frame .ts.gpib.tbar -relief raised -borderwidth 1
button .ts.gpib.tbar.link -image button_attach -command {connectGPIB}
label .ts.gpib.tbar.portlab -text "GPIB:"
entry .ts.gpib.tbar.port -textvariable gpib_board -width 2 -background white
label .ts.gpib.tbar.addrlab -text " Address:"
entry .ts.gpib.tbar.addr -textvariable dev_addr -width 2 -background white
checkbutton .ts.gpib.tbar.null -text "append NULL" -variable append_null

button .ts.gpib.tbar.s -text "Send" -width 4 -command { sendGPIB "$Txdata" }
#-------------------------------------------------------------------------------
labelframe .ts.gpib.tx -text "Tx data" -relief raised -borderwidth 1
entry .ts.gpib.tx.tab -font Courier -width 40 -background white -textvariable Txdata
bind .ts.gpib.tx.tab <Return> {sendGPIB "$Txdata"}
#-------------------------------------------------------------------------------
labelframe .ts.gpib.rx -text "Rx data" -relief raised -borderwidth 1
entry .ts.gpib.rx.tab -font Courier -width 40 -background white -textvariable Rxdata
#-------------------------------------------------------------------------------
frame .ts.gpib.td
label .ts.gpib.td.tt -text "Known GPIB sequences"
proc fillAliases {} {
  global DEBUG GPIB newcmd str_newcmd
  table .ts.gpib.td 0,0 .ts.gpib.td.tt -cspan 2
  set newcmd ""
  entry .ts.gpib.td.newcmd -textvariable newcmd -width 10 
  entry .ts.gpib.td.str_newcmd -textvariable str_newcmd -width 40
  table .ts.gpib.td 1,0  .ts.gpib.td.newcmd -anchor e 1,1 .ts.gpib.td.str_newcmd -anchor w
  set i 2
  foreach k [dict keys $GPIB] {
    if {$DEBUG} {puts stderr "DEBUG: GPIB shorthand \"$k\" becomes \"[dict get $GPIB $k]\""}
    label .ts.gpib.td.${k} -text "$k"
    global ${k}_gpib
    entry .ts.gpib.td.str_${k} -textvariable ${k}_gpib -width 40
    set ${k}_gpib [dict get $GPIB $k]
    table .ts.gpib.td $i,0 .ts.gpib.td.${k} -anchor e $i,1 .ts.gpib.td.str_${k} -anchor w
    incr i
    }
  }
fillAliases
bind .ts.gpib.td.str_newcmd <Return> {
  set i [expr [llength [dict keys $GPIB]] + 2]
  label .ts.gpib.td.${newcmd} -text "$newcmd"
  global ${newcmd}_gpib
  set ${newcmd}_gpib $str_newcmd
  entry .ts.gpib.td.str_${newcmd} -textvariable ${newcmd}_gpib -width 40
  table .ts.gpib.td $i,0 .ts.gpib.td.${newcmd} -anchor e $i,1 .ts.gpib.td.str_${newcmd} -anchor w
  dict append GPIB ${newcmd} ${str_newcmd}
  lappend gpibCommands ${newcmd} ${str_newcmd}
  set newcmd ""; set str_newcmd ""
  if {$DEBUG} {puts stderr "DEBUG: row $i added, gpibCommands = \"$gpibCommands\""}
  }

pack .ts.gpib.tbar.s .ts.gpib.tbar.null -side right
pack .ts.gpib.tbar.link .ts.gpib.tbar.portlab .ts.gpib.tbar.port .ts.gpib.tbar.addrlab .ts.gpib.tbar.addr -side left
pack .ts.gpib.tbar -side top -fill x
pack .ts.gpib.tx -fill x; pack .ts.gpib.tx.tab -anchor w -fill x
pack .ts.gpib.rx -fill x; pack .ts.gpib.rx.tab -anchor w -fill x
pack .ts.gpib.td -side top -fill x -expand 1

.ts tab configure GPIB -window .ts.gpib -anchor n -fill x

### pop-up help ----------------------------------------------------------------------------

tooltip::tooltip .ts.lv.tbar.vdev "Select the camera from the list\nIf only one, it will autoconnect"
tooltip::tooltip .ts.settings.actions.saveConfig "Save the settings into a .cfg file"
tooltip::tooltip .ts.settings.actions.loadConfig "Load the settings from a .cfg file"
tooltip::tooltip .ts.settings.executeMacro "Execute the tcl commands from the widget below"
tooltip::tooltip .ts.lv.tbar.reset "(Re)Connect the selected camera"
tooltip::tooltip .ts.lv.tbar.cool "Toggle the power to the camera sensor cooler"
tooltip::tooltip .ts.lv.tbar.snap "Get a full-frame snapshot from the camera"
tooltip::tooltip .ts.lv.tbar.loop "Continuous snapshots. Uncheck to stop the (infinite) loop."
tooltip::tooltip .ts.lv.tbar.target "Turn cooler power on to reach this temperature\nHit <Enter> in the widget to change value"
tooltip::tooltip .ts.lv.tbar.temp "Current temperature of the camera sensor"
tooltip::tooltip .ts.lv.tbar.etime "Exposure time\nHit <Enter> in the widget to change value"
tooltip::tooltip .ts.lv.tbar.zoom "The zoom settings affects display only,\nfull-resolution image remains in memory"
tooltip::tooltip .ts.sp.tbar.roi "Region Of Interest\nHit <Enter> in the widget to recalculate the spectrum from ROI"
tooltip::tooltip .ts.sp.tbar.reset "Recalculate the spectrum from ROI"
tooltip::tooltip .ts.sp.tbar.dy "Size of the band of interest, in pixels\nHit <Enter> in the widget to recalculate ROI & the spectrum"
tooltip::tooltip .ts.sp.rbar.vs "Start of the band of interest, in pixels\nHit <Enter> in the widget to recalculate ROI & the spectrum"
tooltip::tooltip .ts.sp.rbar.x "x-coordinate of the cursor, in pixels"
tooltip::tooltip .ts.sp.rbar.y "y-coordinate of the cursor, in spectral intensity"
tooltip::tooltip .ts.gpib.tx.tab "Hit <Enter> in the widget to send the command"
tooltip::tooltip .ts.gpib.rx.tab "Response from the GPIB device, if any"
tooltip::tooltip .ts.gpib.td.newcmd "Declare a new GPIB command alias"
tooltip::tooltip .ts.gpib.td.str_newcmd "Hit <Enter> in the widget to add\nthe new GPIB command alias to the table"

### tcl main code ----------------------------------------------------------------------------

update

if {$DEBUG} { puts stderr "DEBUG: first call to C library. If segfault now, reset camera hardware" }

# do these initializations after the widgets are in place

findAllCameras
set nCameras [llength $listOfCameras]
if {$DEBUG} { puts stderr "DEBUG: found $nCameras" }
if { $nCameras > 1 } {
  setStatus "warning" "Found $nCameras cameras, select one"
  set cameraId -1
  set cameraNow ""
  } \
elseif { $nCameras == 1 } { 
  set cameraId 0
  set cameraNow [lindex $listOfCameras $cameraId]
  setStatus "ok" "Auto-selected $cameraId: $cameraNow"
  } \
else {
  setStatus "error" "No compatible cameras available"
  }

if {$DEBUG} { puts stderr "DEBUG: cameraId = $cameraId now" }

if {$cameraId >= 0} {
  connectCamera; resetCamera
  if {$DEBUG} { puts stderr "DEBUG: cameraMode = $ASI_CAMERA_MODE([ASIGetCameraMode $cameraId])"}
  set targetMin [dict get $cameraControls(TargetTemp) min]000
  set targetMax [dict get $cameraControls(TargetTemp) max]
  .ts.lv.tbar.target configure -from $targetMin -to $targetMax -increment 1 
  .ts.lv.tbar.snap configure -fg red -bg white
  .ts.lv.tbar.cool configure -fg cyan -bg white 
  .ts.lv.tbar.reset configure -fg black
  }

### GPIB connection -----------------------------------------------------
#set Txdata "MEAS:VOLT:DC? DEF,DEF"
#set Txdata "O2000"

set run true

if {$DEBUG} { puts stderr "DEBUG: starting main loop" }
while {$run == true} {
  update
  after 500
  if {$cameraId >= 0} {
    set currentTemp [getValue $cameraId [getControlIndex Temperature]]
    set currentTempC [format "  T=%+.1f\u00B0C" [expr $currentTemp/10.0]]
    set coolPowerPerc [getValue $cameraId [getControlIndex CoolPowerPerc]]
    .ts.lv.tbar.ltarget configure -text "\u00B0C  pwr=$coolPowerPerc%"
    } \
  else {
    set currentTempC "T=----"
    .ts.lv.tbar.ltarget configure -text "\u00B0C  pwr=---%"
    }
  }
